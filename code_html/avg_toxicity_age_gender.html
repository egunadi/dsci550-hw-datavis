<!DOCTYPE html>
  <head>
    <meta charset="UTF-8">
    <style>
      /* simple reset */
      html,body,div,span,applet,object,iframe,h1,h2,
      h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,
      address,big,cite,code,del,dfn,em,img,ins,kbd,q,
      s,samp,small,strike,strong,sub,sup,tt,var,b,u,
      i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,
      legend,table,caption,tbody,tfoot,thead,tr,th,
      td,article,aside,canvas,details,embed,figure,
      figcaption,footer,header,hgroup,menu,nav,
      output,ruby,section,summary,time,mark,audio,
      video
      {
      margin:0;
      padding:0;
      border:0;
      font-size:100%;
      font: inherit;
      vertical-align: baseline;
      }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/6.2.0/d3.min.js"></script>
  </head>
  <body>
    <div id="viz"></div>

    <script>
      let margin = {top: 60, right: 30, bottom: 30, left: 30}
          width = 960 - margin.right - margin.left,
          height = 500 - margin.top - margin.bottom;

      d3.csv('../data/Pixstory/avg_toxicity_age_gender.csv', (d) => {
        return d;
      }).then((pixstory) => {
        genders = pixstory.columns.slice(1)
        agegender = genders.flatMap(gender => pixstory.map(d => ({agegroup: d.name, gender, toxicity: d[gender]}))); // pivot longer

        chart = GroupedBarChart(agegender, {
          x: d => d.agegroup,
          y: d => d.toxicity * 100,
          z: d => d.gender,
          yLabel: "↑ Avg Toxicity (%)",
          zDomain: genders,
          colors: d3.schemeSpectral[4],
          width,
          height: 500
        });

        svg = d3.select('#viz')
                .append('svg')
                .attr('width', width + margin.right + margin.left)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left}, ${margin.top})`)
                .append(() => chart)
                .append(legend({
                          color: d3.scaleOrdinal(["male", "female", "others"], d3.schemeSpectral[4]),
                          title: "Gender",
                          tickSize: 0
                        }))

      }).catch((error) => {

        throw error;

      });

      // Copyright 2021 Observable, Inc.
      // Released under the ISC license.
      // https://observablehq.com/@d3/grouped-bar-chart
      function GroupedBarChart(data, {
        x = (d, i) => i, // given d in data, returns the (ordinal) x-value
        y = d => d, // given d in data, returns the (quantitative) y-value
        z = () => 1, // given d in data, returns the (categorical) z-value
        title, // given d in data, returns the title text
        marginTop = 30, // top margin, in pixels
        marginRight = 0, // right margin, in pixels
        marginBottom = 30, // bottom margin, in pixels
        marginLeft = 40, // left margin, in pixels
        width = 640, // outer width, in pixels
        height = 400, // outer height, in pixels
        xDomain, // array of x-values
        xRange = [marginLeft, width - marginRight], // [xmin, xmax]
        xPadding = 0.1, // amount of x-range to reserve to separate groups
        yType = d3.scaleLinear, // type of y-scale
        yDomain, // [ymin, ymax]
        yRange = [height - marginBottom, marginTop], // [ymin, ymax]
        zDomain, // array of z-values
        zPadding = 0.05, // amount of x-range to reserve to separate bars
        yFormat, // a format specifier string for the y-axis
        yLabel, // a label for the y-axis
        colors = d3.schemeTableau10, // array of colors
      } = {}) {
        // Compute values.
        const X = d3.map(data, x);
        const Y = d3.map(data, y);
        const Z = d3.map(data, z);

        // Compute default domains, and unique the x- and z-domains.
        if (xDomain === undefined) xDomain = X;
        if (yDomain === undefined) yDomain = [0, d3.max(Y)];
        if (zDomain === undefined) zDomain = Z;
        xDomain = new d3.InternSet(xDomain);
        zDomain = new d3.InternSet(zDomain);

        // Omit any data not present in both the x- and z-domain.
        const I = d3.range(X.length).filter(i => xDomain.has(X[i]) && zDomain.has(Z[i]));

        // Construct scales, axes, and formats.
        const xScale = d3.scaleBand(xDomain, xRange).paddingInner(xPadding);
        const xzScale = d3.scaleBand(zDomain, [0, xScale.bandwidth()]).padding(zPadding);
        const yScale = yType(yDomain, yRange);
        const zScale = d3.scaleOrdinal(zDomain, colors);
        const xAxis = d3.axisBottom(xScale).tickSizeOuter(0);
        const yAxis = d3.axisLeft(yScale).ticks(height / 60, yFormat);

        // Compute titles.
        if (title === undefined) {
          const formatValue = yScale.tickFormat(100, yFormat);
          title = i => `${X[i]}\n${Z[i]}\n${formatValue(Y[i])}`;
        } else {
          const O = d3.map(data, d => d);
          const T = title;
          title = i => T(O[i], i, data);
        }

        const svg = d3.create("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height])
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

        svg.append("g")
            .attr("transform", `translate(${marginLeft},0)`)
            .call(yAxis)
            .call(g => g.select(".domain").remove())
            .call(g => g.selectAll(".tick line").clone()
                .attr("x2", width - marginLeft - marginRight)
                .attr("stroke-opacity", 0.1))
            .call(g => g.append("text")
                .attr("x", -marginLeft)
                .attr("y", 10)
                .attr("fill", "currentColor")
                .attr("text-anchor", "start")
                .text(yLabel));

        const bar = svg.append("g")
          .selectAll("rect")
          .data(I)
          .join("rect")
            .attr("x", i => xScale(X[i]) + xzScale(Z[i]))
            .attr("y", i => yScale(Y[i]))
            .attr("width", xzScale.bandwidth())
            .attr("height", i => yScale(0) - yScale(Y[i]))
            .attr("fill", i => zScale(Z[i]));

        if (title) bar.append("title")
            .text(title);

        svg.append("g")
            .attr("transform", `translate(0,${height - marginBottom})`)
            .call(xAxis);

        return Object.assign(svg.node(), {scales: {color: zScale}});
      }

      function legend({
        color,
        title,
        tickSize = 6,
        width = 320,
        height = 44 + tickSize,
        marginTop = 18,
        marginRight = 0,
        marginBottom = 16 + tickSize,
        marginLeft = 30,
        ticks = width / 64,
        tickFormat,
        tickValues
      } = {}) {
        const svg = d3.select("svg")
          .attr("width", width)
          .attr("height", height)
          .attr("viewBox", [0, 0, width, height])
          .style("overflow", "visible")
          .style("display", "block");

        let tickAdjust = g => g.selectAll(".tick line").attr("y1", marginTop + marginBottom - height);
        let x;

        // Continuous
        if (color.interpolate) {
          const n = Math.min(color.domain().length, color.range().length);

          x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));

          svg.append("image")
            .attr("x", marginLeft)
            .attr("y", marginTop)
            .attr("width", width - marginLeft - marginRight)
            .attr("height", height - marginTop - marginBottom)
            .attr("preserveAspectRatio", "none")
            .attr("xlink:href", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());
        }

        // Sequential
        else if (color.interpolator) {
          x = Object.assign(color.copy()
            .interpolator(d3.interpolateRound(marginLeft, width - marginRight)), {
              range() {
                return [marginLeft, width - marginRight];
              }
            });

          svg.append("image")
            .attr("x", marginLeft)
            .attr("y", marginTop)
            .attr("width", width - marginLeft - marginRight)
            .attr("height", height - marginTop - marginBottom)
            .attr("preserveAspectRatio", "none")
            .attr("xlink:href", ramp(color.interpolator()).toDataURL());

          // scaleSequentialQuantile doesn’t implement ticks or tickFormat.
          if (!x.ticks) {
            if (tickValues === undefined) {
              const n = Math.round(ticks + 1);
              tickValues = d3.range(n).map(i => d3.quantile(color.domain(), i / (n - 1)));
            }
            if (typeof tickFormat !== "function") {
              tickFormat = d3.format(tickFormat === undefined ? ",f" : tickFormat);
            }
          }
        }

        // Threshold
        else if (color.invertExtent) {
          const thresholds = color.thresholds ? color.thresholds() // scaleQuantize
            :
            color.quantiles ? color.quantiles() // scaleQuantile
            :
            color.domain(); // scaleThreshold

          const thresholdFormat = tickFormat === undefined ? d => d :
            typeof tickFormat === "string" ? d3.format(tickFormat) :
            tickFormat;

          x = d3.scaleLinear()
            .domain([-1, color.range().length - 1])
            .rangeRound([marginLeft, width - marginRight]);

          svg.append("g")
            .selectAll("rect")
            .data(color.range())
            .join("rect")
            .attr("x", (d, i) => x(i - 1))
            .attr("y", marginTop)
            .attr("width", (d, i) => x(i) - x(i - 1))
            .attr("height", height - marginTop - marginBottom)
            .attr("fill", d => d);

          tickValues = d3.range(thresholds.length);
          tickFormat = i => thresholdFormat(thresholds[i], i);
        }

        // Ordinal
        else {
          x = d3.scaleBand()
            .domain(color.domain())
            .rangeRound([marginLeft, width - marginRight]);

          svg.append("g")
            .selectAll("rect")
            .data(color.domain())
            .join("rect")
            .attr("x", x)
            .attr("y", marginTop)
            .attr("width", Math.max(0, x.bandwidth() - 1))
            .attr("height", height - marginTop - marginBottom)
            .attr("fill", color);

          tickAdjust = () => {};
        }

        svg.append("g")
          .attr("transform", `translate(0,${height - marginBottom})`)
          .call(d3.axisBottom(x)
            .ticks(ticks, typeof tickFormat === "string" ? tickFormat : undefined)
            .tickFormat(typeof tickFormat === "function" ? tickFormat : undefined)
            .tickSize(tickSize)
            .tickValues(tickValues))
          .call(tickAdjust)
          .call(g => g.select(".domain").remove())
          .call(g => g.append("text")
            .attr("x", marginLeft)
            .attr("y", marginTop + marginBottom - height - 6)
            .attr("fill", "currentColor")
            .attr("text-anchor", "start")
            .attr("font-weight", "bold")
            .text(title));

        return svg.node();
      }

      function ramp(color, n = 256) {
        var canvas = document.createElement('canvas');
        canvas.width = n;
        canvas.height = 1;
        const context = canvas.getContext("2d");
        for (let i = 0; i < n; ++i) {
          context.fillStyle = color(i / (n - 1));
          context.fillRect(i, 0, 1, 1);
        }
        return canvas;
      }
    </script>
  </body>
</html>